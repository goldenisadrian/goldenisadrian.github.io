<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Art Converter</title>
  <style>
    :root{--panel-bg:#0f1720;--muted:#9aa6b2;--accent:#2dd4bf}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,#0b1116,#071019);color:#e6eef6;padding:18px 18px 8px 18px;box-sizing:border-box}
    /* App layout */
    .app{display:grid;grid-template-columns:320px 1fr;gap:18px;min-height:calc(100vh - 26px);align-items:start}
    .panel{background:rgba(255,255,255,0.03);padding:14px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.6);display:flex;flex-direction:column}
    .panel.left{overflow:auto;max-height:calc(100vh - 72px)}
    .panel.right{height:calc(100vh - 72px);overflow:auto}

    h2{margin:4px 0 12px;font-size:16px}
    /* palette layout */
    .palette-wrap{position:relative;padding:12px}
    .palette{display:grid;grid-template-columns:repeat(8,1fr);gap:12px;margin-top:6px}
    .swatch{width:100%;padding-bottom:100%;border-radius:8px;position:relative;cursor:pointer;border:3px solid rgba(255,255,255,0.03);box-shadow:inset 0 -8px rgba(0,0,0,0.28)}
    .swatch.selected{outline:3px solid var(--accent);transform:scale(1.02)}
    .controls{display:flex;flex-direction:column;gap:10px}
    label{font-size:13px;color:var(--muted)}
    input[type=range]{width:100%}
    .row{display:flex;gap:8px;align-items:center}
    .row > *{flex:1}
    .upload-area{display:flex;flex-direction:column;gap:8px}
    .upload-area input{display:none}
    .btn{background:var(--accent);color:#002;display:inline-block;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
    .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .canvas-row{display:flex;gap:18px;align-items:stretch}
    .box{background:#071224;padding:12px;border-radius:8px;min-width:160px;display:flex;flex-direction:column}
    .meta{display:flex;gap:8px;align-items:center;justify-content:space-between}
    canvas{background:#0a0f16;border-radius:6px;image-rendering:pixelated;max-width:100%;display:block}
    .small{font-size:12px;color:var(--muted)}
    .top-info{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:8px}
    .result-area{display:flex;flex-direction:column;gap:8px;align-items:center}
    .palette-actions{display:flex;gap:8px;margin-top:8px}
    .notice{font-size:13px;color:#cbd5e1;margin-top:6px}
    .footer-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
    .muted-btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:6px;color:var(--muted);cursor:pointer}
    ul.small{margin:6px 0 0 18px}

    /* processing overlay */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .processing{pointer-events:auto;background:rgba(0,0,0,0.5);padding:10px 14px;border-radius:8px;display:flex;gap:10px;align-items:center}
    .spinner{width:18px;height:18px;border-radius:50%;border:3px solid rgba(255,255,255,0.12);border-top-color:var(--accent);animation:spin 900ms linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    @media (max-width:900px){.app{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel left">
      <h2>Palette & Options</h2>
      <div class="controls">
        <div>
          <label>Available palette (click to include/exclude)</label>
          <div class="palette-wrap">
            <div id="palette" class="palette" aria-label="palette"></div>
          </div>

          <div class="palette-actions">
            <button id="selectAll" class="btn secondary">Select All</button>
            <button id="clearAll" class="btn secondary">Clear</button>
          </div>

          <div class="group-buttons" id="categoryButtons" style="margin-top:8px"></div>

          <div class="notice">
            <strong>Dithering styles:</strong>
            <ul class="small">
              <li><strong>None</strong> — direct color mapping (fastest).</li>
              <li><strong>Ordered (Bayer)</strong> — patterned halftones; good for synthetic/artsy looks.</li>
              <li><strong>Floyd–Steinberg / Jarvis / Stucki / Burkes</strong> — error-diffusion methods for smoother gradients.</li>
              <li><strong>Sierra family</strong> — slightly different spreads; Sierra-3 & Sierra-2 added for finer control.</li>
              <li><strong>Atkinson</strong> — lighter diffusion often used in retro graphics.</li>
              <li><strong>Random</strong> — adds noise to reduce banding.</li>
            </ul>
            <div style="height:6px"></div>
            <strong>Pixel scale:</strong> lower values keep more detail; higher values make larger blocky pixels and are faster to process.
          </div>

        </div>

        <div>
          <label for="dither">Dithering</label>
          <select id="dither">
            <option value="none">None</option>
            <option value="floyd">Floyd–Steinberg</option>
            <option value="burkes">Burkes</option>
            <option value="jarvis">Jarvis</option>
            <option value="stucki">Stucki</option>
            <option value="sierra">Sierra (full)</option>
            <option value="sierra3">Sierra-3</option>
            <option value="sierra2">Sierra-2</option>
            <option value="sierralite">Sierra–Lite</option>
            <option value="atkinson">Atkinson</option>
            <option value="bayer2">Bayer 2x2</option>
            <option value="bayer4">Bayer 4x4</option>
            <option value="ordered">Ordered (Bayer 8x8)</option>
            <option value="random">Random noise</option>
          </select>
        </div>

        <div>
          <label for="pixelScale">Pixel scale (1 = most detailed, higher = bigger blocks)</label>
          <input id="pixelScale" type="range" min="1" max="48" value="8">
          <div class="small">Current reduction factor: <span id="pixelScaleVal">8</span></div>
        </div>

        <div>
          <label for="displayScale">Result display scale (visual zoom)</label>
          <input id="displayScale" type="range" min="1" max="48" value="8">
          <div class="small">Display scale: <span id="displayScaleVal">8</span>x</div>
        </div>

        <div>
          <label>Preview options</label>
          <div class="row">
            <label class="small"><input id="showGrid" type="checkbox"> Show grid (pixel borders)</label>
          </div>
        </div>

        <div class="footer-actions">
          <button id="downloadBtn" class="btn">Download Result</button>
        </div>

      </div>
    </div>

    <div class="panel right">
      <div class="upload-area">
        <div class="top-info">
          <div>
            <strong>Upload an image</strong>
            <div class="small">PNG, JPG, GIF — max practical size ~3000px</div>
          </div>
          <div>
            <label class="btn" for="fileInput">Choose file</label>
            <input id="fileInput" type="file" accept="image/*">
          </div>
        </div>

        <div class="canvas-row">
          <div style="flex:1;min-width:220px;">
            <div id="origBox" class="box">
              <div class="meta"><strong>Original</strong><span id="origSize" class="small">—</span></div>
              <div style="position:relative;flex:1;display:flex;align-items:center;justify-content:center">
                <canvas id="origCanvas" title="Click to choose a new image" style="cursor:pointer;max-width:100%;"></canvas>
              </div>
            </div>
          </div>

          <div style="flex:1;min-width:220px;">
            <div id="resultBox" class="box result-area" style="position:relative">
              <div style="width:100%">
                <div class="meta"><strong>Result</strong>
                  <div style="display:flex;gap:8px;align-items:center">
                    <div id="resultSize" class="small">—</div>
                    <div id="pixelCount" class="small">—</div>
                  </div>
                </div>
                <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
                  <label class="small">Scale:</label>
                  <input id="displayScaleInput" type="number" min="1" max="48" value="8" style="width:72px;padding:6px;border-radius:6px;border:none;background:#071224;color:#dbeafe">
                </div>
              </div>

              <div style="position:relative;flex:1;display:flex;align-items:center;justify-content:center">
                <canvas id="resultCanvas"></canvas>
                <div id="processingOverlay" class="overlay" style="display:none"><div class="processing"><div class="spinner"></div><div><div id="processingText">Processing…</div><div id="processingMode" style="font-size:11px;color:var(--muted)"></div></div></div></div>
              </div>

              <div class="small" style="margin-top:6px">Right-click the result to save or use the Download button.</div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  // Palette provided by user
  const PALETTE = [
"#000000","#3c3c3c","#787878","#aaaaaa","#d2d2d2","#ffffff",
"#600018","#a50e1e","#ed1c24","#fa8072","#e45c1a","#ff7f27",
"#f6aa09","#f9dd3b","#fffabc","#9c8431","#c5ad31","#e8d45f",
"#4a6b3a","#5a944a","#84c573","#0eb968","#13e67b","#87ff5e",
"#0c816e","#10aea6","#13e1be","#0f799f","#60f7f2","#bbfaf2",
"#28509e","#4093e4","#7dc7ff","#4d31b8","#6b50f6","#99b1fb",
"#4a4284","#7a71c4","#b5aef1","#780c99","#aa38b9","#e09ff9",
"#cb007a","#ec1f80","#f38da9","#9b5249","#d18078","#fab6a4",
"#684634","#95682a","#dba463","#7b6352","#9c846b","#d6b594",
"#d18051","#f8b277","#ffc5a5","#6d643f","#948c6b","#cdc59e",
"#333941","#6d758d","#b3b9d1"
  ];

  // DOM
  const paletteEl = document.getElementById('palette');
  const selectAll = document.getElementById('selectAll');
  const clearAll = document.getElementById('clearAll');
  const ditherSelect = document.getElementById('dither');
  const pixelScaleInput = document.getElementById('pixelScale');
  const pixelScaleVal = document.getElementById('pixelScaleVal');
  const displayScale = document.getElementById('displayScale');
  const displayScaleVal = document.getElementById('displayScaleVal');
  const displayScaleInput = document.getElementById('displayScaleInput');
  const showGrid = document.getElementById('showGrid');
  const fileInput = document.getElementById('fileInput');
  const origCanvas = document.getElementById('origCanvas');
  const resultCanvas = document.getElementById('resultCanvas');
  const origSize = document.getElementById('origSize');
  const resultSize = document.getElementById('resultSize');
  const pixelCount = document.getElementById('pixelCount');
  const downloadBtn = document.getElementById('downloadBtn');
  const categoryButtons = document.getElementById('categoryButtons');
  const processingOverlay = document.getElementById('processingOverlay');
  const processingText = document.getElementById('processingText');
  const processingMode = document.getElementById('processingMode');
  const origBox = document.getElementById('origBox');
  const resultBox = document.getElementById('resultBox');

  // Canvas contexts and reusable canvases
  const origCtx = origCanvas.getContext('2d');
  const resultCtx = resultCanvas.getContext('2d');
  const work = document.createElement('canvas');
  const tmp = document.createElement('canvas');
  let workCtx = work.getContext('2d');
  let tmpCtx = tmp.getContext('2d');

  let img = new Image();
  let imgLoaded = false;

  // palette state
  const paletteState = PALETTE.map(c => ({hex:c, active:true, rgb:hexToRgb(c)}));

  // caching for nearest color lookups
  const colorCache = new Map();

  // Worker setup
  let worker = null; let workerAvailable = false;
  try{
    const blob = new Blob([`(${workerFn.toString()})()`], {type:'application/javascript'});
    const url = URL.createObjectURL(blob);
    worker = new Worker(url);
    workerAvailable = true;
  } catch(e){ workerAvailable = false; console.warn('Worker unavailable', e); }

  if(worker){
    worker.onmessage = function(e){
      const msg = e.data;
      if(msg && msg.type === 'result'){
        // re-create image data from transferred buffer
        try{
          const w = msg.width, h = msg.height;
          const imgData = new ImageData(new Uint8ClampedArray(msg.data), w, h);
          // putImageData into tmp and draw
          tmp.width = w; tmp.height = h; tmpCtx = tmp.getContext('2d');
          tmpCtx.putImageData(imgData, 0, 0);
          drawResultFromTmp(w,h);
        } catch(err){
          console.error('Error applying worker result', err);
          alert('Rendering failed after worker processing. Try increasing pixel scale or display scale.');
        } finally{
          setProcessing(false);
        }
      }
    };
  }

  // processing overlay control
  function setProcessing(on, mode){
    if(on){
      processingOverlay.style.display = 'flex';
      processingText.textContent = 'Processing…';
      processingMode.textContent = mode ? `Mode: ${mode}` : '';
    } else { processingOverlay.style.display = 'none'; processingMode.textContent = ''; }
  }

  function drawResultFromTmp(targetW, targetH){
    // draw scaled for display and update stats
    const scale = Math.max(1, parseInt(displayScale.value,10));
    // attempt to draw, but guard against too-large canvases: cap final canvas size
    const MAX_DISPLAY_DIM = 8192; // conservative
    let outW = targetW * scale, outH = targetH * scale;
    let downscaleFactor = Math.max(1, Math.ceil(Math.max(outW / MAX_DISPLAY_DIM, outH / MAX_DISPLAY_DIM)));
    if(downscaleFactor > 1){ outW = Math.floor(outW / downscaleFactor); outH = Math.floor(outH / downscaleFactor); }

    resultCanvas.width = outW; resultCanvas.height = outH;
    resultCtx.clearRect(0,0,outW,outH);
    resultCtx.imageSmoothingEnabled = false;
    try{
      // drawImage may throw if source tmp is too large for GPU; catch and fallback
      resultCtx.drawImage(tmp, 0, 0, outW, outH);
    } catch(e){
      console.warn('drawImage failed, attempting safe fallback', e);
      // fallback: draw in smaller steps — draw at 1:1 if possible
      try{
        const smallW = Math.max(1, Math.floor(outW/2));
        const smallH = Math.max(1, Math.floor(outH/2));
        const small = document.createElement('canvas'); small.width = smallW; small.height = smallH;
        const sctx = small.getContext('2d'); sctx.imageSmoothingEnabled=false; sctx.drawImage(tmp, 0, 0, smallW, smallH);
        resultCtx.drawImage(small, 0, 0, outW, outH);
      } catch(err){
        console.error('Fallback draw failed', err);
        resultCtx.fillStyle = '#111'; resultCtx.fillRect(0,0,outW,outH);
      }
    }

    // grid
    if(showGrid.checked && scale>1){
      resultCtx.save(); resultCtx.strokeStyle='rgba(0,0,0,0.35)'; resultCtx.lineWidth=1;
      const step = scale; for(let x=0;x<=resultCanvas.width; x+=step){ resultCtx.beginPath(); resultCtx.moveTo(x+0.5,0); resultCtx.lineTo(x+0.5,resultCanvas.height); resultCtx.stroke(); }
      for(let y=0;y<=resultCanvas.height; y+=step){ resultCtx.beginPath(); resultCtx.moveTo(0,y+0.5); resultCtx.lineTo(resultCanvas.width,y+0.5); resultCtx.stroke(); }
      resultCtx.restore();
    }

    // If we downscaled for display because of device limits, explain in overlay briefly
    if(downscaleFactor>1){ processingMode.textContent = `Display capped (factor ${downscaleFactor}) — downloaded image remains ${targetW}×${targetH}`; }

    resultSize.textContent = targetW + ' x ' + targetH;
    pixelCount.textContent = (targetW * targetH) + ' pixels';

    // sync preview sizes
    syncBoxHeights();
    setProcessing(false);
  }

  // equalize box heights for neat layout
  function syncBoxHeights(){
    // reset heights
    origBox.style.height = '';
    resultBox.style.height = '';
    // measure
    const o = origBox.getBoundingClientRect();
    const r = resultBox.getBoundingClientRect();
    const maxH = Math.max(o.height, r.height);
    // leave small gap to bottom
    origBox.style.height = Math.max(160, Math.floor(maxH)) + 'px';
    resultBox.style.height = Math.max(160, Math.floor(maxH)) + 'px';
  }

  function buildPaletteUI(){
    paletteEl.innerHTML = '';
    paletteState.forEach((p, i) => {
      const d = document.createElement('div');
      d.className = 'swatch' + (p.active ? ' selected' : '');
      d.title = p.hex;
      d.style.background = p.hex;
      d.dataset.index = i;
      d.addEventListener('click', () => {
        p.active = !p.active;
        d.classList.toggle('selected', p.active);
        colorCache.clear(); // palette changed -> clear cache
        scheduleUpdate();
      });
      paletteEl.appendChild(d);
    });
  }

  function buildCategoryButtons(){
    const cats = [
      {id:'neutrals', label:'Neutrals'},
      {id:'reds', label:'Reds'},
      {id:'oranges', label:'Oranges'},
      {id:'yellows', label:'Yellows'},
      {id:'greens', label:'Greens'},
      {id:'cyans', label:'Cyans'},
      {id:'blues', label:'Blues'},
      {id:'purples', label:'Purples'},
      {id:'pinks', label:'Pinks'},
      {id:'browns', label:'Browns'}
    ];
    categoryButtons.innerHTML='';
    cats.forEach(cat=>{
      const btn = document.createElement('button');
      btn.className='muted-btn'; btn.textContent=cat.label;
      btn.addEventListener('click', ()=>toggleCategory(cat.id));
      categoryButtons.appendChild(btn);
    });
  }

  selectAll.addEventListener('click', ()=>{paletteState.forEach(p=>p.active=true); colorCache.clear(); buildPaletteUI(); scheduleUpdate();});
  clearAll.addEventListener('click', ()=>{paletteState.forEach(p=>p.active=false); colorCache.clear(); buildPaletteUI(); scheduleUpdate();});

  // debounce updates from continuous controls
  let debounceTimer = null;
  function debounceSchedule(){ clearTimeout(debounceTimer); debounceTimer = setTimeout(()=>scheduleUpdate(), 120); }

  pixelScaleInput.addEventListener('input', ()=>{pixelScaleVal.textContent = pixelScaleInput.value; debounceSchedule();});
  displayScale.addEventListener('input', ()=>{displayScaleVal.textContent = displayScale.value; displayScaleInput.value = displayScale.value; debounceSchedule();});
  displayScaleInput.addEventListener('change', ()=>{let v = Math.max(1,Math.min(48,Number(displayScaleInput.value)||1));displayScaleInput.value=v;displayScale.value=v;displayScaleVal.textContent=v; scheduleUpdate();});
  showGrid.addEventListener('change', scheduleUpdate);
  ditherSelect.addEventListener('change', scheduleUpdate);

  fileInput.addEventListener('change', (e)=>{
    if(!e.target.files || !e.target.files[0]) return;
    const f = e.target.files[0];
    const url = URL.createObjectURL(f);
    loadImage(url);
  });

  downloadBtn.addEventListener('click', ()=>{
    // download the 1:1 tmp canvas (target pixels) so it matches displayed pixel count
    if(!imgLoaded) return;
    const a = document.createElement('a');
    a.href = tmp.toDataURL('image/png');
    a.download = 'pixel-art-1x.png';
    a.click();
  });

  // clicking original canvas opens upload dialog (no URL prompt)
  origCanvas.addEventListener('click', ()=>{ fileInput.click(); });

  function loadImage(src){
    imgLoaded = false;
    img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = ()=>{
      imgLoaded = true;
      // cache rgb values for palette
      paletteState.forEach(p=>{p.rgb = hexToRgb(p.hex);});
      // cap original canvas preview size
      const maxDisplay = 600;
      const scale = Math.min(1, maxDisplay / Math.max(img.width, img.height));
      origCanvas.width = Math.round(img.width * scale);
      origCanvas.height = Math.round(img.height * scale);
      origCtx.clearRect(0,0,origCanvas.width,origCanvas.height);
      origCtx.drawImage(img, 0, 0, origCanvas.width,origCanvas.height);
      origSize.textContent = img.width + ' x ' + img.height;
      scheduleUpdate(true);
    };
    img.onerror = ()=>{alert('Error loading image');}
    img.src = src;
  }

  // Utilities
  function hexToRgb(hex){
    const h = hex.replace('#','');
    return {r:parseInt(h.substring(0,2),16),g:parseInt(h.substring(2,4),16),b:parseInt(h.substring(4,6),16)};
  }

  function rgbToHsl(r,g,b){
    r/=255;g/=255;b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h=0,s=0,l=(max+min)/2; if(max===min) h=s=0; else{ const d=max-min; s = l>0.5?d/(2-max-min):d/(max+min); switch(max){case r: h=(g-b)/d + (g<b?6:0); break; case g: h=(b-r)/d + 2; break; case b: h=(r-g)/d + 4; break;} h/=6;} return {h:h*360,s,l};
  }

  function colorDist2(a,b){
    const dr=a.r-b.r, dg=a.g-b.g, db=a.b-b.b; return dr*dr+dg*dg+db*db;
  }

  // main processing: worker or main-thread
  let updateToken = 0;
  function scheduleUpdate(forceImmediate){
    const t = ++updateToken;
    if(forceImmediate) processImage(t); else requestAnimationFrame(()=>processImage(t));
  }

  function processImage(tok){
    if(tok !== updateToken) return;
    if(!imgLoaded) return;

    const factor = Math.max(1, parseInt(pixelScaleInput.value,10));
    const targetW0 = Math.max(1, Math.floor(img.width / factor));
    const targetH0 = Math.max(1, Math.floor(img.height / factor));

    // guard: cap target resolution to avoid browser canvas limits
    const MAX_TARGET_DIM = 8192; // conservative cap
    let scaleDown = Math.max(1, Math.ceil(Math.max(targetW0 / MAX_TARGET_DIM, targetH0 / MAX_TARGET_DIM)));
    const targetW = Math.max(1, Math.floor(targetW0 / scaleDown));
    const targetH = Math.max(1, Math.floor(targetH0 / scaleDown));

    // draw scaled down into work canvas
    work.width = targetW; work.height = targetH; workCtx = work.getContext('2d');
    workCtx.clearRect(0,0,work.width,work.height);
    workCtx.drawImage(img, 0, 0, targetW, targetH);
    const src = workCtx.getImageData(0,0,targetW,targetH);

    const method = ditherSelect.value;
    const activePalette = paletteState.filter(p=>p.active).map(p=>p.rgb);

    // show processing indicator
    setProcessing(true, workerAvailable ? 'worker' : 'main');

    if(workerAvailable && worker){
      try{
        // transfer src buffer
        worker.postMessage({type:'process', width:targetW, height:targetH, data:src.data.buffer, method, palette:activePalette}, [src.data.buffer]);
        return;
      } catch(e){
        console.warn('Worker transfer failed, falling back to main thread', e);
        // continue to main-thread
      }
    }

    // fallback main-thread processing
    const dst = workCtx.createImageData(targetW,targetH);
    try{
      mainThreadProcess(src.data, dst.data, targetW, targetH, method, activePalette);
      tmp.width = targetW; tmp.height = targetH; tmpCtx = tmp.getContext('2d');
      tmpCtx.putImageData(dst,0,0);
      drawResultFromTmp(targetW,targetH);
    } catch(err){
      console.error('Main-thread processing failed', err);
      alert('Processing failed — try increasing pixel scale to reduce target size.');
      setProcessing(false);
    }
  }

  // main-thread processing implementation
  function mainThreadProcess(srcBuf, dstBuf, W, H, method, paletteRgb){
    const palette = paletteRgb && paletteRgb.length ? paletteRgb : PALETTE.map(hexToRgb);
    function nearest(r,g,b){ let best=null, bd=Infinity; for(const p of palette){ const d = (p.r-r)*(p.r-r)+(p.g-g)*(p.g-g)+(p.b-b)*(p.b-b); if(d<bd){bd=d;best=p;} } return best; }
    if(method === 'none'){
      for(let i=0;i<srcBuf.length;i+=4){ const r=srcBuf[i],g=srcBuf[i+1],b=srcBuf[i+2]; const c=nearest(r,g,b); dstBuf[i]=c.r; dstBuf[i+1]=c.g; dstBuf[i+2]=c.b; dstBuf[i+3]=255; }
      return;
    }
    if(method === 'bayer2' || method === 'bayer4' || method === 'ordered'){
      let matrix = method==='bayer2'?[[0,2],[3,1]]:method==='bayer4'?ORDERED_BAYER_4:generateBayer(8);
      const n = matrix.length, denom = n*n;
      for(let y=0;y<H;y++) for(let x=0;x<W;x++){ const idx=(y*W+x)*4; const r=srcBuf[idx],g=srcBuf[idx+1],b=srcBuf[idx+2]; const tval=(matrix[y%n][x%n]+0.5)/denom-0.5; const off=Math.round(tval*255); const nr=clamp(r+off,0,255), ng=clamp(g+off,0,255), nb=clamp(b+off,0,255); const c=nearest(nr,ng,nb); dstBuf[idx]=c.r; dstBuf[idx+1]=c.g; dstBuf[idx+2]=c.b; dstBuf[idx+3]=255; }
      return;
    }
    if(method === 'random'){
      for(let i=0;i<srcBuf.length;i+=4){ const r=srcBuf[i],g=srcBuf[i+1],b=srcBuf[i+2]; const noise=(Math.random()-0.5)*64; const c=nearest(clamp(Math.round(r+noise),0,255), clamp(Math.round(g+noise),0,255), clamp(Math.round(b+noise),0,255)); dstBuf[i]=c.r; dstBuf[i+1]=c.g; dstBuf[i+2]=c.b; dstBuf[i+3]=255; }
      return;
    }
    // error diffusion
    let kernel;
    if(method === 'floyd') kernel=[{x:1,y:0,f:7/16},{x:-1,y:1,f:3/16},{x:0,y:1,f:5/16},{x:1,y:1,f:1/16}];
    else if(method === 'burkes') kernel=[{x:1,y:0,f:8/32},{x:2,y:0,f:4/32},{x:-2,y:1,f:2/32},{x:-1,y:1,f:4/32},{x:0,y:1,f:8/32},{x:1,y:1,f:4/32},{x:2,y:1,f:2/32}];
    else if(method === 'jarvis') kernel=[{x:1,y:0,f:7/48},{x:2,y:0,f:5/48},{x:-2,y:1,f:3/48},{x:-1,y:1,f:5/48},{x:0,y:1,f:7/48},{x:1,y:1,f:5/48},{x:2,y:1,f:3/48},{x:-2,y:2,f:1/48},{x:-1,y:2,f:3/48},{x:0,y:2,f:5/48},{x:1,y:2,f:3/48},{x:2,y:2,f:1/48}];
    else if(method === 'stucki') kernel=[{x:1,y:0,f:8/42},{x:2,y:0,f:4/42},{x:-2,y:1,f:2/42},{x:-1,y:1,f:4/42},{x:0,y:1,f:8/42},{x:1,y:1,f:4/42},{x:2,y:1,f:2/42},{x:-2,y:2,f:1/42},{x:-1,y:2,f:2/42},{x:0,y:2,f:4/42},{x:1,y:2,f:2/42},{x:2,y:2,f:1/42}];
    else if(method === 'atkinson') kernel=[{x:1,y:0,f:1/8},{x:2,y:0,f:1/8},{x:-1,y:1,f:1/8},{x:0,y:1,f:1/8},{x:1,y:1,f:1/8},{x:0,y:2,f:1/8}];
    else if(method === 'sierra') kernel=SIERRA_FULL;
    else if(method === 'sierra3') kernel=SIERRA_3;
    else if(method === 'sierra2') kernel=SIERRA_2;
    else if(method === 'sierralite') kernel=SIERRA_LITE_KERNEL;
    else kernel=[{x:1,y:0,f:7/16},{x:-1,y:1,f:3/16},{x:0,y:1,f:5/16},{x:1,y:1,f:1/16}];

    const rbuf = new Float32Array(W*H); const gbuf = new Float32Array(W*H); const bbuf = new Float32Array(W*H);
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){ const i=y*W+x; const idx=i*4; rbuf[i]=srcBuf[idx]; gbuf[i]=srcBuf[idx+1]; bbuf[i]=srcBuf[idx+2]; }
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const i=y*W+x; const oldR=rbuf[i], oldG=gbuf[i], oldB=bbuf[i]; const c=nearest(Math.round(oldR), Math.round(oldG), Math.round(oldB)); dstBuf[i*4]=c.r; dstBuf[i*4+1]=c.g; dstBuf[i*4+2]=c.b; dstBuf[i*4+3]=255; const errR = oldR - c.r, errG = oldG - c.g, errB = oldB - c.b;
        for(const k of kernel){ const nx=x+k.x, ny=y+k.y; if(nx<0||ny<0||nx>=W||ny>=H) continue; const ni=ny*W+nx; rbuf[ni]+=errR*k.f; gbuf[ni]+=errG*k.f; bbuf[ni]+=errB*k.f; }
      }
    }
  }

  // helpers
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  // category toggles
  function toggleCategory(cat){
    paletteState.forEach(p=>{
      const hsl = rgbToHsl(p.rgb.r,p.rgb.g,p.rgb.b);
      const catMatch = matchCategory(hsl);
      if(catMatch===cat){ p.active = !p.active; }
    }); colorCache.clear(); buildPaletteUI(); scheduleUpdate();
  }
  function matchCategory(hsl){ const {h,s,l}=hsl; if(s<0.6&&l<0.65&&h>=15&&h<60) return 'browns'; if(s<0.08||l<0.06||l>0.94) return 'neutrals'; if(h>=345||h<15) return 'reds'; if(h>=15&&h<35) return 'oranges'; if(h>=35&&h<70) return 'yellows'; if(h>=70&&h<170) return 'greens'; if(h>=170&&h<200) return 'cyans'; if(h>=200&&h<260) return 'blues'; if(h>=260&&h<300) return 'purples'; if(h>=300&&h<345) return 'pinks'; return 'browns'; }

  // init
  buildPaletteUI(); buildCategoryButtons();
  pixelScaleVal.textContent = pixelScaleInput.value;
  displayScaleVal.textContent = displayScale.value;
  displayScaleInput.value = displayScale.value;

  // drag & drop
  document.body.addEventListener('dragover',(e)=>{e.preventDefault();});
  document.body.addEventListener('drop',(e)=>{e.preventDefault(); if(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]){ fileInput.files = e.dataTransfer.files; const ev = new Event('change'); fileInput.dispatchEvent(ev); }});

  // Worker function embedded
  function workerFn(){
    self.onmessage = function(e){
      const msg = e.data; if(!msg || msg.type!=='process') return; const W=msg.width, H=msg.height; const srcBuf=new Uint8ClampedArray(msg.data); const method=msg.method; const palette = (msg.palette && msg.palette.length) ? msg.palette.map(p=>({r:p.r,g:p.g,b:p.b})) : null;
      function nearestLocal(r,g,b){ let best=null, bd=Infinity; const list = palette || self.PALETTE_FALLBACK; for(const p of list){ const d=(p.r-r)*(p.r-r)+(p.g-g)*(p.g-g)+(p.b-b)*(p.b-b); if(d<bd){bd=d;best=p;} } return best; }
      const ORDERED_BAYER_4=[[0,8,2,10],[12,4,14,6],[3,11,1,9],[15,7,13,5]];
      function generateBayer(n){ if(n===1) return [[0]]; const half=n/2; const small=generateBayer(half); const res=Array.from({length:n}, ()=>Array(n).fill(0)); for(let y=0;y<half;y++) for(let x=0;x<half;x++){ const v=small[y][x]; res[y][x]=4*v; res[y][x+half]=4*v+2; res[y+half][x]=4*v+3; res[y+half][x+half]=4*v+1;} return res; }
      const SIERRA_FULL=[{x:1,y:0,f:5/32},{x:2,y:0,f:3/32},{x:-2,y:1,f:2/32},{x:-1,y:1,f:4/32},{x:0,y:1,f:5/32},{x:1,y:1,f:4/32},{x:2,y:1,f:2/32},{x:-1,y:2,f:2/32},{x:0,y:2,f:3/32},{x:1,y:2,f:2/32}];
      const SIERRA_3=[{x:1,y:0,f:4/16},{x:2,y:0,f:3/16},{x:-2,y:1,f:1/16},{x:-1,y:1,f:2/16},{x:0,y:1,f:3/16},{x:1,y:1,f:2/16},{x:2,y:1,f:1/16},{x:-1,y:2,f:1/16},{x:0,y:2,f:2/16},{x:1,y:2,f:1/16}];
      const SIERRA_2=[{x:1,y:0,f:4/16},{x:2,y:0,f:3/16},{x:-1,y:1,f:1/16},{x:0,y:1,f:2/16},{x:1,y:1,f:1/16}];
      const SIERRA_LITE=[{x:1,y:0,f:2/4},{x:-1,y:1,f:1/4},{x:0,y:1,f:1/4}];
      const dstBuf=new Uint8ClampedArray(W*H*4);
      if(method==='none'){ for(let i=0;i<srcBuf.length;i+=4){ const r=srcBuf[i],g=srcBuf[i+1],b=srcBuf[i+2]; const c=nearestLocal(r,g,b); dstBuf[i]=c.r; dstBuf[i+1]=c.g; dstBuf[i+2]=c.b; dstBuf[i+3]=255; } }
      else if(method==='bayer2'||method==='bayer4'||method==='ordered'){ let matrix = method==='bayer2'?[[0,2],[3,1]]:method==='bayer4'?ORDERED_BAYER_4:generateBayer(8); const n=matrix.length, denom=n*n; for(let y=0;y<H;y++) for(let x=0;x<W;x++){ const idx=(y*W+x)*4; const r=srcBuf[idx],g=srcBuf[idx+1],b=srcBuf[idx+2]; const tval=(matrix[y%n][x%n]+0.5)/denom-0.5; const off=Math.round(tval*255); const nr=clamp(r+off,0,255), ng=clamp(g+off,0,255), nb=clamp(b+off,0,255); const c=nearestLocal(nr,ng,nb); dstBuf[idx]=c.r; dstBuf[idx+1]=c.g; dstBuf[idx+2]=c.b; dstBuf[idx+3]=255; } }
      else if(method==='random'){ for(let i=0;i<srcBuf.length;i+=4){ const r=srcBuf[i],g=srcBuf[i+1],b=srcBuf[i+2]; const noise=(Math.random()-0.5)*64; const c=nearestLocal(clamp(Math.round(r+noise),0,255), clamp(Math.round(g+noise),0,255), clamp(Math.round(b+noise),0,255)); dstBuf[i]=c.r; dstBuf[i+1]=c.g; dstBuf[i+2]=c.b; dstBuf[i+3]=255; } }
      else { let kernel; if(method==='floyd') kernel=[{x:1,y:0,f:7/16},{x:-1,y:1,f:3/16},{x:0,y:1,f:5/16},{x:1,y:1,f:1/16}]; else if(method==='burkes') kernel=[{x:1,y:0,f:8/32},{x:2,y:0,f:4/32},{x:-2,y:1,f:2/32},{x:-1,y:1,f:4/32},{x:0,y:1,f:8/32},{x:1,y:1,f:4/32},{x:2,y:1,f:2/32}]; else if(method==='jarvis') kernel=[{x:1,y:0,f:7/48},{x:2,y:0,f:5/48},{x:-2,y:1,f:3/48},{x:-1,y:1,f:5/48},{x:0,y:1,f:7/48},{x:1,y:1,f:5/48},{x:2,y:1,f:3/48},{x:-2,y:2,f:1/48},{x:-1,y:2,f:3/48},{x:0,y:2,f:5/48},{x:1,y:2,f:3/48},{x:2,y:2,f:1/48}]; else if(method==='stucki') kernel=[{x:1,y:0,f:8/42},{x:2,y:0,f:4/42},{x:-2,y:1,f:2/42},{x:-1,y:1,f:4/42},{x:0,y:1,f:8/42},{x:1,y:1,f:4/42},{x:2,y:1,f:2/42},{x:-2,y:2,f:1/42},{x:-1,y:2,f:2/42},{x:0,y:2,f:4/42},{x:1,y:2,f:2/42},{x:2,y:2,f:1/42}]; else if(method==='atkinson') kernel=[{x:1,y:0,f:1/8},{x:2,y:0,f:1/8},{x:-1,y:1,f:1/8},{x:0,y:1,f:1/8},{x:1,y:1,f:1/8},{x:0,y:2,f:1/8}]; else if(method==='sierra') kernel=SIERRA_FULL; else if(method==='sierra3') kernel=SIERRA_3; else if(method==='sierra2') kernel=SIERRA_2; else if(method==='sierralite') kernel=SIERRA_LITE; else kernel=[{x:1,y:0,f:7/16},{x:-1,y:1,f:3/16},{x:0,y:1,f:5/16},{x:1,y:1,f:1/16}]; const rbuf=new Float32Array(W*H), gbuf=new Float32Array(W*H), bbuf=new Float32Array(W*H); for(let y=0;y<H;y++) for(let x=0;x<W;x++){ const i=y*W+x; const idx=i*4; rbuf[i]=srcBuf[idx]; gbuf[i]=srcBuf[idx+1]; bbuf[i]=srcBuf[idx+2]; } for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const i=y*W+x; const oldR=rbuf[i], oldG=gbuf[i], oldB=bbuf[i]; const c=nearestLocal(Math.round(oldR), Math.round(oldG), Math.round(oldB)); dstBuf[i*4]=c.r; dstBuf[i*4+1]=c.g; dstBuf[i*4+2]=c.b; dstBuf[i*4+3]=255; const errR=oldR-c.r, errG=oldG-c.g, errB=oldB-c.b; for(const k of kernel){ const nx=x+k.x, ny=y+k.y; if(nx<0||ny<0||nx>=W||ny>=H) continue; const ni=ny*W+nx; rbuf[ni]+=errR*k.f; gbuf[ni]+=errG*k.f; bbuf[ni]+=errB*k.f; } } } }
      // return buffer
      self.postMessage({type:'result', width:W, height:H, data:dstBuf.buffer}, [dstBuf.buffer]);
    };
    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    self.PALETTE_FALLBACK=[{r:0,g:0,b:0},{r:255,g:255,b:255}];
  }

})();
</script>
</body>
</html>

